; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26131.1 

	TITLE	C:\Users\Pavel\Documents\Visual Studio 2017\Projects\ovm_3\ovm_3\Source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_main
PUBLIC	__xmm@00000002000000050000000100000003
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT __xmm@00000002000000050000000100000003
CONST	SEGMENT
__xmm@00000002000000050000000100000003 DB 03H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 05H, 00H, 00H, 00H, 02H, 00H, 00H, 00H
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\pavel\documents\visual studio 2017\projects\ovm_3\ovm_3\source.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv333 = -36						; size = 4
_i$1$ = -32						; size = 4
_tmp$1$ = -28						; size = 4
_mass$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 3    : int main() {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4    : 	int n = 5;
; 5    : 	int mass[5] = {3, 1, 5, 2, 4};

	movaps	xmm0, XMMWORD PTR __xmm@00000002000000050000000100000003

; 6    : 	
; 7    : 	int i, j, step;
; 8    : 	int tmp;
; 9    : 	for (step = n / 2; step > 0; step /= 2)

	mov	edx, 2
	push	ebx
	push	esi
	movups	XMMWORD PTR _mass$[ebp], xmm0
	mov	DWORD PTR _mass$[ebp+16], 4
	push	edi
	npad	6
$LL4@main:

; 10   : 		for (i = step; i < n; i++) {

	mov	ebx, edx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	edx, 5
	jge	SHORT $LN2@main
	lea	esi, DWORD PTR _mass$[ebp]
	mov	DWORD PTR tv333[ebp], esi
$LL7@main:

; 11   : 			tmp = mass[i];

	mov	eax, DWORD PTR _mass$[ebp+ebx*4]
	mov	DWORD PTR _tmp$1$[ebp], eax

; 12   : 			for (j = i; j >= step; j -= step) {

	mov	eax, ebx
	cmp	ebx, edx
	jl	SHORT $LN11@main

; 11   : 			tmp = mass[i];

	lea	ebx, DWORD PTR [edx*4]
$LL10@main:

; 13   : 				if (tmp < mass[j - step])

	mov	edi, DWORD PTR [esi]
	mov	ecx, eax
	sub	ecx, edx
	cmp	DWORD PTR _tmp$1$[ebp], edi
	jge	SHORT $LN26@main

; 14   : 					mass[j] = mass[j - step];

	mov	DWORD PTR _mass$[ebp+eax*4], edi
	sub	esi, ebx
	mov	eax, ecx
	cmp	eax, edx
	jge	SHORT $LL10@main
$LN26@main:
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	esi, DWORD PTR tv333[ebp]
$LN11@main:

; 15   : 				else
; 16   : 					break;
; 17   : 			}
; 18   : 			mass[j] = tmp;

	mov	ecx, DWORD PTR _tmp$1$[ebp]
	inc	ebx
	add	esi, 4
	mov	DWORD PTR _mass$[ebp+eax*4], ecx
	mov	DWORD PTR _i$1$[ebp], ebx
	mov	DWORD PTR tv333[ebp], esi
	cmp	ebx, 5
	jl	SHORT $LL7@main
$LN2@main:

; 6    : 	
; 7    : 	int i, j, step;
; 8    : 	int tmp;
; 9    : 	for (step = n / 2; step > 0; step /= 2)

	mov	eax, edx
	cdq
	sub	eax, edx
	mov	edx, eax
	sar	edx, 1
	test	edx, edx
	jg	SHORT $LL4@main

; 19   : 		}
; 20   : 
; 21   : 	return 0;
; 22   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END
